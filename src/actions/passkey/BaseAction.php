<?php

namespace blackcube\admin\actions\passkey;

use blackcube\admin\models\Passkey;
use Symfony\Component\Serializer\Encoder\JsonEncode;
use Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer;
use Webauthn\AttestationStatement\AttestationStatementSupportManager;
use Webauthn\AttestationStatement\NoneAttestationStatementSupport;
use Webauthn\AuthenticatorAssertionResponseValidator;
use Webauthn\AuthenticatorAttestationResponseValidator;
use Webauthn\AuthenticatorSelectionCriteria;
use Webauthn\CeremonyStep\CeremonyStepManagerFactory;
use Webauthn\Denormalizer\WebauthnSerializerFactory;
use Wolfcast\BrowserDetection;
use yii\helpers\Json;
use Yii;

abstract class BaseAction extends \yii\base\Action
{
    public $authenticatorAttachment = AuthenticatorSelectionCriteria::AUTHENTICATOR_ATTACHMENT_PLATFORM;
    public $userVerification = AuthenticatorSelectionCriteria::USER_VERIFICATION_REQUIREMENT_REQUIRED;
    public $challengeLength = 32;
    public $timeout = 60000;

    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        Yii::$app->response->format = \yii\web\Response::FORMAT_JSON;
    }

    protected function savePasskey($publicKeyCredentialSource)
    {
        $browserDetection = new BrowserDetection();
        $data = $this->toArray($publicKeyCredentialSource);
        $passkey = Yii::createObject(Passkey::class);
        $passkey->id = $data['publicKeyCredentialId'];
        $passkey->name = $browserDetection->getName().' / '.$browserDetection->getPlatformVersion();
        $passkey->administratorId = $this->base64UrlDecode($data['userHandle']);
        $passkey->type = $data['type'];
        $passkey->attestationType = $data['attestationType'];
        $passkey->aaguid = $data['aaguid'];
        $passkey->credentialPublicKey = $data['credentialPublicKey'];
        $passkey->userHandle = $data['userHandle'];
        $passkey->counter = $data['counter'];
        $passkey->jsonData = Json::encode($data);
        return $passkey->save() ? true : $passkey->errors;
    }

    protected function getCheckAttestationCeremony()
    {
        $csmFactory = new CeremonyStepManagerFactory();
        $creationCSM = $csmFactory->creationCeremony();
        return AuthenticatorAttestationResponseValidator::create(
            $creationCSM
        );
    }
    protected function getCheckAssertionCeremony()
    {
        $csmFactory = new CeremonyStepManagerFactory();
        $assertionCSM = $csmFactory->requestCeremony();
        return AuthenticatorAssertionResponseValidator::create(
            $assertionCSM
        );
    }
    protected function toArray($data)
    {
        $jsonString = $this->getSerializer()->serialize($data, 'json',
            [ // Optional
                AbstractObjectNormalizer::SKIP_NULL_VALUES => true,
                JsonEncode::OPTIONS => JSON_THROW_ON_ERROR,
            ]);
        return Json::decode($jsonString);
    }
    protected function toObject($data, $class)
    {
        if (is_array($data)) {
            $data = Json::encode($data);
        }
        return $this->getSerializer()->deserialize($data, $class, 'json');
    }
    protected function getSerializer()
    {
        $attestationStatementSupportManager = AttestationStatementSupportManager::create();
        $attestationStatementSupportManager->add(NoneAttestationStatementSupport::create());
        $factory = new WebauthnSerializerFactory($attestationStatementSupportManager);
        $serializer = $factory->create();
        return $serializer;
    }

    protected function base64UrlDecode($data, $strict = false)
    {
        // Convert Base64URL to Base64 by replacing “-” with “+” and “_” with “/”
        $b64 = strtr($data, '-_', '+/');

        // Decode Base64 string and return the original data
        return base64_decode($b64, $strict);
    }

    protected function base64UrlEncode($data)
    {
        // Convert Base64 to Base64URL by replacing “+” with “-” and “/” with “_”
        $b64 = base64_encode($data);
        $urlEncoded = strtr($b64, '+/', '-_');
        return rtrim($urlEncoded, '=');
    }
}